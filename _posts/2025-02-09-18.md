---
layout: single
title: "C++ : deque, 중간 삽입/삭제, Map, 자료구조 알고리즘 "
categories: "C++"
tag: [C++,C++강의]

author_profile: true
sidebar:
    nav: "counts"
---

## deque

deque: double - ended queue 데크

-> 리스트와 벡터의 중간정도인 느낌이다 자주활용하지는 않는다.

->  [          ] 기존의 데이터는 냅두고 [          ] 하나의 데이터를 더 늘린다. 데이터를 옮기지 않는다.  그래서 메모리가 다찼으면 하나를 또 만들어 그거를 연결한다. 그래서 벡터와 리스트의 특성을 합쳤다.

->백터와 마찬가지로 배열 기반으로 동작 다만 메모리 할당 정책이 다르다

​    

deque의 처음/끝 삽입/삭제 -> 둘다 빠르다. 새로운 통을 하나 늘려서 거기다가 넣을 수 있어서 빠름 벡터처럼 계속 메모리가 옮기고 다니지않는다.

deque 중간 삽입/삭제   -> 벡터처럼 중간이 삭제되면 데이터가 비어져있으면 안되고 모든 데이터가 한칸씩 당겨진다. 그리고 중간에 삽입해도 밀어줘서 거기에 넣어야한다. 그래서 벡터와 마찬가지로 느리다. 

deque 임의접근: 좋다! 빠르게 일어난다. , 벡터와는 다르게 블록 단위로 떨어져있다. 그래서 만약에 10번째 단위는 어디에있습니까하면 다 떨어져있어서 어떻게 이동할까하고 메모리를 보면 

[1호 2호 3호 4호    ]4동

[    ]3동 

[    ]2동

[    ]1동        -> 이런식으로 몇동몇호인지에 대한 그런 주소를 다른 테이블로 관리하고 있다. 내가  어떤 데이터를 접근하고싶은지(데이터의 개수) 넣어주면 몇동몇호에 있다는 것을 역으로 계산해줘서 그주소로 한번에 순간이동한다.

그래서 이게 가능하기 위해서는 중간중간에 비어있는 상태이면 계산할수 없음

그래서 중간 삽입/삭제가 느린이유이다.

deque는 양방향으로 사용하는 큐이다 그러닌간 앞쪽에 넣어놓고 삭제하는거랑 뒤쪽에 넣고 삭제하는 것은 빠르지만 나머지 특징은 벡터랑 굉장히 유사하다.

벡터는 앞에서 데이터를 밀어넣는게 느렸던 이유는 모든 데이터들을 한칸씩 밀거나 아니면 삭제하거나 해서 다 땅겨지거나 밀어지는데

deque같은 경우는 맨앞이나 맨뒤에 데이터를 추가하게 되면은 채워주다가 꽉찼으면 통하나를 크게 늘려서 거기다가 넣는다. 그래서 빠르게 동작한다.

-중간 삽입/삭제 중요

vector = 동적 배열 = 동적으로 커지는 배열 = 배열

원소가 하나의 메모리 블록에 연속하게 저장된다!!



## 중간 삽입/삭제    

벡터같은 경우의 중간 삽입/삭제란 :-> [0] [1] [2] [3] [4] [] [ ] [ ]  2자리에 5를 쓰고싶으면 234를 하나씩 쭉 뒤로 밀고 넣어야한다. [0] [1] [5] [2] [3] [4] [ ] [ ]   (중간 삽입/삭제 비효율적임) 쭉 밀어야하닌 비효율이다. [0] [1] [ ] [3] [4] 중간에 비어있으면 안된다.배열의 특성상 쭉 이어져야 있어야한다.

그래서 중간을 지우면 다 땡겨와야한다. 그래서 중간 삽입/삭제는 비효율적이다.

​    

벡터같은 경우의 처음/끝 삽입/삭제 :-> [] [1] [2] [3] [4] [ ] [ ]  -> 0을 없애면 다 땡겨야한다. 그래서 처음 삽입하는 일은 비효율적이다. 똑같이 근데 끝에 삭제하는 것은 다이어져있으닌간 조건에 만족하닌간 딱히 움직이는게 없다. 그래서 효율적이다. 

​    

벡터같은 경우의 임의 접근: 3번째 데이터는 어디 있습니까? v[2]=3; 즉 배열형태로 지원하는 이유는 옹기종기 다 뭉쳐있어서 가능하다. 그럼 배열처럼 , 내가 원하는 데이터를 세는게 아니라 내가 원하는 번호로 뿅 가서 접근 가능하다.

근데 중간에 삽입삭제가 가끔 필요할 수도있다.

->v.insert(v.begin()+2,5); -> 맨처음에가서 2번 앞으로 이동해서 그 자리에 5를 넣어라 그리고 앞으로 쫙 밀림 메모리가 그리고 가르키는 위치가 5를 가르키고 있다.

insert -> 어떤 위치에다가 무엇을 넣어줄거냐라는 의미이다.

->v.erase(v.begin()+2); 지울 때 사용 5를 지워주면 그 자리를 또 가르키고 있다.

->v.erase(v.begin()+2,v.begin()+4) : v.begin()+4 여기 앞에까지 삭제 특정범위까지 삭제 하라는 의미이다.

->삭제한 위치를 다 땅겨오닌간 그 자리를 가르키고 있다.

​    

쭉 스캔을 하면서 3이라는 데이터가 있으면 일괄 삭제하고 싶다

->

```c++
for(vactor<int>::iterator it = v.begin(); it !=v.end(); ++it)

{

 int data = *it;

 if(data==3)

 {

  v.erase(it);

 }

}

```

 -> 스크래치난다. iterator랑 포인터랑 비슷하지만 iterator에는 추가적인 정보를 들고있다. 진짜 소속이된 컨테이너의 정보를 내부적으로 들고있다. 근데 v.erase를 한다는 의미는 삭제가 되어서 컨테이너 소속이 안된 상태이다. 그래서 어떤 형태로도 사용하면 안된다. 근데 ++하닌간 스크래치가 난다. 그래서 결국에는 v.earse(it);하고 break;로 나와야함 아니면 쭉 보고싶으면 it=v.erase(it);를해야함 그럼 삭제를한순간에 이터레이터는 다시 들고와서 그 주소를 들고있다.

갱신하면 ptr는 별 차이는 없다. 그리고 _yproxy가 null이 아니다. 멀 들고있다. 근데 이렇게하면 삭제하고 그 주소를 다시 가르키게 만드는건데 삭제를하면서 한칸씩 당껴져서 다음데이터가아니라 그 데이터를 다시보고 가야하는데 누락된다. 예를들어 123456789가있어서 3을 삭제시키면 12456789가있고 3자리임 4자리를 가르키고있을텐데 4를확인해야하는데 다음 데이터인 5를 확인한다. 그래서 위에서 ++it하는게아니라 else{ ++it;}을 넣어줘야한다.

​    

그래서 중요했던 내용이 for문을 이용해서 스캔을 하고 특정조건을 삭제하거나 어디를 추가할 때 굉장히 조심하게 사용해야한다. 예를들어 v.clear();이걸 사용하면 끝나야하는데 for문으로 계속 증가하면 메모리가 점점상한다.



## Map

모든걸 다 벡터,리스트로 만들면? -> 데이터를 빠르게 찾을 수 있는 방법이 없다. , 원하는 조건에 해당하는 데이터를 빠르게 찾을 수 없다

​    

map

-연관 컨테이너

-균형 이진 트리(AVL)

-노드 기반

->Map이 멀 들고있는지

```c++ 
class Node

{

public:

 Node* _left;

 Node* right;

​    

 int _key;

 Player* _value;

};
```

map<int,int> m;  -> (Key,Value) 값으로 저장된 key는 트리의 순서 왼쪽 오른쪽 중 어디에 저장이 되어있어야하는지 구성하는 그위치이다.

​    

pair<int,Player*> ->멤버 변수를 두 개 들고있다.

```c++
for(int i=0; i<100000; i++)
{

	m.insert(pair<int,int>(i,i*100))

}
```

-> pair로 만든값을 넣는다.  , 키값도 int value도 int값이다.  키값에는 i에 들어가고 value값에는 i*100값이 들어감 저장한다.



```c++    
for(int i=0; i<50000; i++)

{

 int randomValue = rand()%50000;

 m.erase(randomValue); -> 키값을 이용하여 삭제함

}
```

->ID=1만인 player찾고 싶다

->매우 빠르게 찾을 수 있다.

​    

m.find(10000); -> 1만번인 아이디를 찾는다.

```c++
map<int,int>::iterator findlt = m.find(10000);

if(findlt !=m.end())

{

 cout<<“찾음”<<endl

}
```

같은키에 대해서 insert를 하거나 erase를 두 번씩하면 어떤일이 일어날까?

erase를 두번하면

->딱히 큰 문제가 되는건 없다.

insert를 두 번하면 같은 키에 다른 데이터를 넣으면?

->m.insert(marke_pair(1,100); m.insert(marke_pair(1,200);

->키 1에 값은 100이다. 값이 안바뀐다.

​    

pair<map<int,int>::iterator,bool> ok; ->ok라는 첫 번째값은 인서트한 반한값을 저장하고 인서트한 두 번째 값은 성공여부를 bool값으로 알려준다. 그래서 두 번째 돌리면 false나온다. 첫 번째에는 true나온다.

​    

map순회

-> iterator를 이용해서 사용해야한다.

```c++
for(map<int,int>::iterator it=m.begin(); it !=m.end(); ++it)

{

 pair<const int, int>& p = (*it); // -> 키랑 벨류값 둘다가지고있음

​        int key = p.firest;   //-> 킷값을 가져옴

​        int value = p.second; //-> 벨류값을 가져옴

}

​    
```

iterator: 맵이냐 벡터냐 리스트냐에 따라서 구현부가 달라진다.

​    

m[5] = 500;  -> 5라는 키가 없으면 그걸 추가한다음에 500이라고 벨류를 생성해라 라는 의미이다.  근데 5라는게 있으면 그값에 벨류를 500으로 수정을 해줘라 라는 의미이다.

​    

[] 연산자 사용할 때 주의할점

->우리가 대입을 하지 않더라도(Key/Value)형태의 데이터가 추가된다!

​    

```c++
m.clear()

for(int i=0; i<10; i++)

{

 cout<<m[i]<<endl;

}
```

-> 없으면 추가한다는 기본적인게 들어가있어서 아무것도없으면 0으로 계속 세팅해준다.

그래서 데이터가 있는지없는지만 확인하고싶으면 이 문법을 쓰면안되고 find를 이용해서 체크를 해야한다.

​    

-넣고(insert,[])

-빼고(erase)

-찾고(find, [])

-반복자(map::iterator) (*it)pair<key,value)&

​    

->추가하거나 인설트를하면 연속적으로 저장되는 개념이아니라 각자 설정된 알고리즘의 따라서 트리가 재구성되면서 알아서 구성하기 때문에 효율적이다.



### Set,Multimap, Multiset

set,multimap,multiset

set<int> s; -> Key=Value 키랑 벨류값이 똑같다.  나머지는 맵이랑 똑같다.

multimp: map에서 중복키를 허용하는 것이다.

multiset: set에서 중복키를 허용하는 것이다.

​    

## 자료구조,알고리즘

자료구조(데이터를 저장하는 구조)

알고리즘(그 데이터를 어떻게 사용할 것인가?)

​    

알고리즘(엄청 많지만 많이사용하는 애들)

count

count_if

all_of

any_of

none_of

for_each

remove

remove_if

​    

### find,find_if,count_if,all_of,any_of,none_of,for_each

find(v.begin(),v.end(),number) ->begin은 포함이되고 end는 포함이안되고(범위지정하고) 

number(찾을값 넣는다.)를 찾는다.

​    

std::find_if(v.begin(),v.end(),CanDivideBy11()) ->범위를 지정해주고 조건을 넣으면 된다. 조건은 함수객체를 넣으면된다.

​    

람다식으로 함수객체를 한번에 만들 수 있다. -> [](int n) {return (n%11) ==0}

->1회성 함수이다.

​    

count_if(v.begin(),v.end(),IsOdd())  ->카운트는 특정 숫자 데이터를 찾는거다.  조건을 걸어서 찾는 것 이다. 함수객체 넣는거 아니면 람다식을 넣으면 된다.

​    

all_of(v.begin(),v.end(),IsOdd());  ->모든 데이터가 만족하느냐라는 의미이다.

any_if(v.begin(),v.end(),IsOdd());    -> 그런 데이터가 하나라도 있느냐라는 의미이다.

none_of(v.begin(),v.end(),IsOdd())    -> 모든 데이터가 하나라도 없나요라는 의미이다.

​    

for_each(v.begin(),v.end(),MultiplayBy3)   ->모든 데이터를 스캔할 때 유용하다.  모든 데이터 대상으로 MultiplayBy3을 실행한다.

   

### remove, remove_if 

vector에서 삭제를하면 비효율적이다.

​    

remove(v.begin(),v.end(),4 );  4를 삭제하고싶다라는 의미이다.

remove_if(v.begin(),v.end(), IsOdd()); 조건을 만족하면 삭제한다라는 의미이다.

-> 근데 값을 보면 엉뚱한값이 들어가있다.

예를 들어 홀수인 애들을 지워준다 했을때

1 4 3 5 8 2   ->원본 데이터

4 8 2 5 8 2    -> 482까지 다봐서 남겨줬으니 여기서 끝내버린다.

4 8 2 5 8 2   ->실행후

데이터가 삭제안되고 바꿔치기 되어있다.

삭제하고 당겨주고 삭제하고 당겨주고하면 불필요한 움직임이여서 필요한 데이터만 남겨주는 동작을한다.

조건에 만족하는애를 찾아준다. -> 처음에는 1을 가르킨다.  그리고 for문을 돌아서 끝까지 쭉본다.  그리고 돌면서 남겨줘야할 애들을 가져와서 빠르게 복사한다 

-> 필요한 데이터만 남겨주겠다

​    

그래서 4 8 2를 남기고 나머지는 다날려줘야해서 사용하지 않아야할 위치를 뱉어내서 4 8 2만 남겨줘야한다.

그래서 remove_if를한다음에 

vector<int>::iterator it = remove_if (v.begin(),v.end(), IsOdd()); ->불필요한 위치애들은 반환한다.



v.erase(it,v.end());

이렇게 해야 4 9 2이렇게 남겨진다.

합쳐서 

-> v.erase(remove_if(v.begin(),v.end(),IsOdd()),v.end());

이렇게하면 된다.