---
layout: single
title: "C++ : 디버깅,콜백 함수"
categories: "C++"
tag: [C++,C++강의]

author_profile: true
sidebar:
    nav: "counts"
---

## 디버깅

디버깅 : 회사를 가면 코드를 작성하는 시간보다 디버깅하면서 보내는 시간이 더 길다. 그래서 중요한 기술이다.

​    

크래시된 상태를 덤프라는걸 남긴다. 그래서 호출스택을 보면서 역으로 유추할 수 있어야한다.

->호출스택 중요

![image-20250118233332946]({{site.url}}/images/2025-01-18-15/image-20250118233332946.png)

브레이크 포인트가 걸린상태에서 우클릭눌러서 조건을 걸 수 있다.  x==20  인경우만 브레이크를 걸겠다 이런식으로 걸 수 있음다그래서 만족하면 브레이크가 걸린다.

위에 사진에서 브레이크 걸고 빨간색 브레이크 부분에 마우스를 대고 우클릭을 하면 조건을 걸 수 있는 부분이 나온다.

​    

브레이크 포인트에 우클릭눌러서 작업을 가면 내가 원하는 출력값만 출력창에 띄우고싶으면 거기다가 쓰면된다.

   

## 콜백 함수

콜백 함수

​    

나중에 서버작업을하면 STL이라는걸 사용한다. 언리얼은 사용안한다.

STL을 공부하기 위해서는 사전 지식이 필요하다. (함수포인터,함수,객체 템플릿)

​    

포인터를볼 때 3가지 측면을 봐야한다.

int* pointer = &a;

1)포인터

2)변수 이름    pointer

3)데이터 타입   int

​    

제3의 타입이 함수라는게 있다.

​    

함수로 타입으로 만드는 개념

함수라는걸 표현하기 위해서는 함수의 모양이 중요하다. 반환값이나 인자값등

```c++
int Add(int a, int b);   //함수의 시그니처

int main()
{
	
	return 0; 
}

int Add(int a, int b)
{
	return a + b;
}
```

int (int a,int b);  -> 함수의 시그니처

typedef int(FUNC_TYPE)(int a, int b);   -> (FUNC_TYPE) -> 함수이름을 만든다.

모던c++에서는 -> using FUNC_TYPE = int(int a, int b) 이런식으로도 가능하다.

 ``` c++
 #include <iostream>
 #include <cstring>
 #pragma warning(disable:4996)
 using namespace std;
 
 int Add(int a , int b);
 
 int main()
 {
 	
 	
 	typedef int(FUNC_TYPE)(int a, int b);
 	// using FUNC_TYPE = int(int a, int b);   모던 c++에서 사용 가능
 
 	FUNC_TYPE* fn;
 
 
 	// 함수의 이름은 함수의 시작 주소(배열과 유사하다.)
 	int result = Add(1, 2);
 	cout << result << endl;
 
 	// 함수의 이름은 함수의 시작 주소이기때문에 fn은 int 인자 두개를 받아주고 int하나를 반환해주는 그 주소 바구니를 가지고 있는 애이닌간 Add를 담을 수 있다.
 	fn = Add;
 	int result1 = fn(3, 4);
 	cout << result1 << endl;
 
 	// 해당 주소로 이동하라는 접근 연산자를 사용할 수 있는데 함수 포인터는 신기하게 *(접근 연산자)를 붙여도 함수 주소이다!
 	//int result1 = (*fn)(3, 4);
 	//cout << result1 << endl;
 
 
 	return 0; 
 }
 
 int Add(int a, int b)
 {
 	return a + b;
 }
 ```

FUNC_TYPE* fn; -> 포인터이다 변수이름은 fn이다 데이터 타입은 함수(인자는 int,int 반환은 int)가 있다

-이제 어떤 함수를 담을 수 있다.

fn = Add; -> 타입은 일치만 하면 이렇게 함수의 주소를 넣을 수 있다. 그래서 함수 포인터이다.

int result = fn(1,2); -> 이제 이런식으로 가능하다. 

int result = (*fn)(1,2);  -> 특이하게 함수 포인터는 접근 연산자 *붙어도 함수 주소임 똑같다.

-위에 두 코드는 어셈블리어를보면 똑같다.

​    

int result = Add(1,2);

->Add 함수라는게 어셈블리어를 보면 주소를 들고있다. 그래서 함수의 이름은 함수의 시작 주소(배열과 유사)이다.  , 어셈블리어에 Call Add(주소값)이렇게 나와있다. 

​    