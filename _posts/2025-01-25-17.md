---
layout: single
title: "C++ : STL,Vector(동적 배열), 반복자, 역방향 반복자, list(연결 리스트)"
categories: "C++"
tag: [C++,C++강의]

author_profile: true
sidebar:
    nav: "counts"
---

## STL

STL(Standard Template Library): 프로그래밍할 때 필요한 자료구조/알고리즘을 템플릿으로 제공하는 라이브러리

컨테이너(Container):데이터를 저장하는 객체 (자료구조 Date Structure 자료를 어떻게 저장할지)

## vector

-면접에 많이나온다



vactor(동적 배열)

-vector의 동작 원리(size/capacity)

-중간 삽입/삭제

-처음/끝 삽입/삭제

-임의 접근

->위에 4가지에 대해서 알아보자!



배열: 10개를 만들었는데 문제는 이제 플레이어나 몬스터가 더 많이 늘어나면 이 배열을 사용할 수 없다.

​    

동적 배열

```c++
#include <iostream>
#include <cstring>
#include <vector>            // include 해서 가져와야한다.
using namespace std;

int main()
{
    // vector 선언: 유동적으로 크기가 변하는 배열
    std::vector<int> v;

    // vector에 데이터 추가 (push_back을 통해 값을 추가)
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    v.push_back(5);

    // 현재 vector에 들어있는 데이터 개수를 size 변수에 저장
    const int size = v.size();

    // vector에 저장된 데이터 출력
    for (int i = 0; i < size; i++) {
        std::cout << v[i] << std::endl;
    }

    return 0;
}
```

매우 매우 중요한 개념 -> 어떤 마법을 부렸길래 배열을 유동적으로 사용한 것인가?

1.여유분을 두고 메모리를 할당한다

2.여유분까지 꽉 찼으면, 메모리를 증설한다

int* arr2 = new int[100];

delete arr2;

arr* = new int[1000];

이런 느낌이다.



Q1) 여유분은 얼만큼이 적당할까?

Q2) 증설을 얼만큼 해야 할까?

Q3) 기존의 데이터를 어떻게 처리할까?



size(실제 사용 데이터 개수)

capacity(여유분을 포함한 용량 개수)

​    

```c++
#include <iostream>
#include <cstring>
#include <vector>            // include 해서 가져와야한다.
using namespace std;

int main()
{
    // vector 선언: 유동적으로 크기가 변하는 배열
    std::vector<int> v;

    // 1000번 반복하며 vector에 100을 추가
    for (int i = 0; i < 1000; i++) {
        v.push_back(100);

        // vector의 크기(size)와 현재 할당된 용량(capacity) 출력
        std::cout << "Size: " << v.size() << " Capacity: " << v.capacity() << std::endl;
    }

    return 0;
}
```

->1 1

   2 2

​    3 3

 이렇게 증가하는데 size는 1 2 3 4 5 6 7... 이렇게 가는데

 capacity는 1 2 3 4 6 9 13 19 28 42 63 이런식으로 증가한다.

 capacity는 컴파일러마다 증가하는 패턴은 다르다. 여기는 1.5배씩 늘어난다.

​    

Q1과 Q2의 질문의 연관이 있다.

이제 [       ]여기서 사용하던걸 초과하게 되면  다른 곳 [             ] 더큰 부분에 옮겨서 복사를 해야하는데 자꾸 복사가 일어나면 처리비용이 많이드닌간 더 큰 크기로 잡아준다. 근데 이걸 엄청많이 잡아둘순없지만 예상을해야한다. 그래서 동적배열에서는 몇배씩 늘리겠다는 정책을 사용한다. 데이터가 두배씩 증가하게 되닌간 엄청 많은 데이터가 들어와도 나중엔 엄청 많은 여유분이 생기닌간 복사해서 옮겨줘서 횟수가 적어진다. -> 처음에는 복사가 많이 늘어난다. 근데 초반에 얼만큼 필요한만큼을 알면 처음에 잡아줄 수 있다. v.reserve(1000) 1000개짜리 크기부터 시작한다.

​    

v.resize(1000); -> 처음부터 사이즈를 정해줌   [               ] 이만큼 사이즈를 쓰고있다.

근데 여유분이 1이라고 하면 이상하닌간 resize로 강제로 만들 때 부족한다면 capacity도 같이 늘어난다.

​    

capacity여유분을 미리 정해둬 복사하는 부분을 최소화시킬 수 있다.

이제 여기서 여유분을 많이 해뒀는데 이만큼 필요가 없으면? 근데 역으로는 줄어들지는 않는다. 초과하면 점점 늘어나는건 한다.

v.clear(); -> 모든 값들을 사용안하겠다 다 날리겠다.(size만 날리고 capacity는 잡아놈 크기만큼있다.

근데 정말로 같이 줄이고 싶다하고 싶으면 꼼수를 써야한다.

vector<int>().swap(v); -> 임시로 만들어줘서 스왑을통해서 내가 가지고 있던애들 거꾸로 임시가 들고있다. 그리고 깡통처럼 아무것도 안들고있던 애를 가져온다.

그리고 마지막으로 실행되면 vector이 임시백터이기 때문에 이줄이 실행되면 임시로 만들어준 애가 소멸되면서 메모리가 해제된다. 근데 실무에서는 깔끔하게 날리지는 않는다. 웬만하면 굳이 안한다.

v.pop_back(); -> 데이터를 빼낼 수 있다.

v.back(); -> 맨뒤에 데이터를 빼낼 수 있다

v.front(); -> 맨 앞에 있는 데이터를 빼낼 수 있다

vector<int> v(1000,0); 만들자마자 resize를 정해줄 수 있음 사이즈를 정하고 초기값을 0으로한다.

vector<int> v2 = v; -> v가가지고 있던 특징을 v2에 다 복사가능하다.



## 반복자

반복자(Iterator) : 포인터와 유사한 개념, 컨테이너의 원소(데이터)를 가리키고, 다음/이전 원소로 이동 가능하다.

```c++
#include <iostream>
#include <cstring>
#include <vector>            // include 해서 가져와야한다.
using namespace std;

int main()
{
    // 크기가 10인 vector 선언
    std::vector<int> v(10);

    // vector에 0부터 9까지 값 할당
    for (vector<int>::size_type i = 0; i < v.size(); i++) {
        v[i] = i;
    }

    // vector의 iterator와 포인터 선언
    vector<int>::iterator it;

    // iterator와 포인터를 vector의 첫 번째 요소로 초기화
    it = v.begin(); // iterator를 vector의 시작 위치로 설정

    // iterator 연산 (포인터처럼 사용 가능)
    it++;   // 다음 요소로 이동
    ++it;   // 다음 요소로 이동 (전위 증가 연산)
    it--;   // 이전 요소로 이동
    --it;   // 이전 요소로 이동 (전위 감소 연산)
    it += 2; // 두 칸 앞으로 이동
    it -= 2; // 두 칸 뒤로 이동

    // 결과 출력
    std::cout << "Current iterator value: " << *it << std::endl;

    return 0;
}
```

-vector<int>::size_type하면 애가 알아서 알맞은 타입을 정해준다.

-vector<int>::iterator it;

-iterator it를 보면 ptr을 들고있다. 그리고 myproxy ,mynextiter 묘한값을 추가적으로 들고있다. 내가 어떤 컨테이너에 소속되어 있는지 가지고 있다. 근데 iterator는 포인터가 아닌데 포인터처럼 이용할 수 있느냐하면 *오퍼레이터를 매핑해서 만들어준다. 문법을 이용하게 만들어준다. 만든사람이 그래서 포인터 외에도 기본라이브러리를 보면 myproxy, mynextiter가 있다. 결국 알 수 있는거 내부적으로 포인터를 들고있다.

​    

vector<int>::iterator itBegin = v.begin();

vector<int>::iterator itEnd = v.end();  -> 끝을 판별할 때 사용한다.

itEnd를 보면 쓰레기값을 들고있다. 끝나는 주소가 이상한가? 라는 생각이 들 수 있다.

메모리를 보면 itBegin 타고가면 [ptr]을 타고가면 0이라는 값을 들고있다. 근데 itend는 들어가면 ptr타고가면 유요한 데이터를 가르키는게 아니라 끝에서 한칸 앞에 있는 유요하지 않는 데이터를 들고있다. 그래서 끝을 판별할 때 사용하는 것 이다.

​    

```c++
for(vector<int>::iterator it = v.begin(); it !=v.end() ++it)
{
 	cout<<(*it)<<endl; 
} 
```

++it하는게 it++하는것보다 좀더 성능적으로 좋다(엄청난 차이는 없음 미세하게 있다)

iterator는 내부적으로 포인터가 숨겨져있다.

```c++
for(vector<int>::iterator it = v.begin(); it !=v.end() ++it)
{
	 cout<<(*it)<<endl; 
} 
```

-이게 더 복잡해보이는데 왜 쓰느냐

1.iterator는 vector뿐 아니라, 다른 컨테이너에도 공통적으로 있는 개념이다.

2.STR한정으로는 통일성이 있어 다른 구조로 넘어갈 때 수월하다.

3.다른 컨테이너는 v[i]와 같은 인덱스 접근이 안 될 수도 있다.

​    

```c++
for(vector<int>:: size_type int i=0; i<v.size; i++) 
{
    v[i]=i;
}

```

이버전 쓰거나 위에 버전쓰거나 큰차이없다.

​    

 const_oterator cit1= v.cbegin();

->const int* 수정안하고 보기만할거면 이걸로 쓰면된다.

*cit1=100; -> 불가능

​    

## 역방향 반복자

역방향 반복자

for(vector<int>::reverse_iterator it = v.rbegin(); it !=v.rend(); ++it)

-> 출력하면 마지막값부터 거꾸로 출력해준다.

->벡터의 역방향 반복자(reverse iterator) 타입입니다.

->일반적인 반복자(iterator)는 앞에서 뒤로 이동하지만, reverse_iterator는 뒤에서 앞으로 이동합니다.

​    

v.rbegin()

->벡터의 역방향 시작 지점을 반환합니다.

  정확히는 벡터의 마지막 요소를 가리키는 반복자를 반환합니다.

v.rend()

->벡터의 역방향 종료 지점을 반환합니다.

   정확히는 벡터의 첫 번째 요소의 이전 위치를 가리키는 반복자입니다.

## list(연결 리스트)

list(연결 리스트)

->노드 방식을 구성되어 있다.

​    

-list의 동작 원리

-중간 삽입/삭제

-처음/끝 삽입/삭제

-임의 접근

->위에 대해서 알아보자!

li.push_back(0); -> 벡터와 똑같이 집어넣는다.

li.push_front(10) -> 벡터에는 삽입 삭제하는게 비효율적이여서 지원하지 않았는데 리스트는 지원한다. 

li.capacity() -> 동적 배열이 아니여서 용량의 개념이 없어서 이런 기능은 없다.  불가능 x

li.front();-> 처음 데이터 추출

il.back();-> 마지막 데이터 추출

li[3] = 10; -> 벡터는 임의접근으로 할수있었는데 리스트는 못한다. 불가능 x

list<int>::iterator it; ->벡터랑 사용하던 이터리터랑은 동작하는게 다르다.

list<int>::iterator itBegin = li.begin(); -> 가능

list<int>::iterator itEnd = li.end(); ->가능

​    

li.insert(itBegin,100); ->가능

li.erase(li.begin()); ->가능  중간값까지 삭제할 수 있는 느낌이다.

li.pop_front(); -> 팝시리즈를 사용하면 맨처음에 있는 끝에 있는애를 삭제할거면 이걸 쓰면된다.

li.remove(10); -> 10이라는 데이터를 삭제하고싶다 이걸 쓰면 10이라는 요소가 있으면 지워준다 벡터는 지원안한다. 삽입삭제 비효율적이여서 근데 리스트에서는 지원하는거보면 빠르게 동작한다는걸 예상이 가능하다.

### list 동작 원리

list 동작 원리

-벡터에 대해서 간단하게 요약하면 -> 벡터는 동적 배열로 이루어진 컨테이너이다.

-list: 연결리스트이다.

->단일/이중/원형 리스트가 있다.

->[1] [2] [3] [4] [5] 이런식으로 순차적으로 데이터가 저장되는건 똑같다. 근데 달라지는 부분은 다 연속된 공간에 배치되어야 한다는 강제사항이 없어진다. [1]        ->  [2]    ->[3]   -> [4]    -> [5] 이렇게 따로따로 배치가 된 다음 서로 존재만 알고 있게끔 다음 데이터가 어디있는지 아는상태로 저장되어있다.

-> 다른 주소를 가르키는건 포인터로 만들어줌 Node* _next; ->다음 노드 연결

->칸 단위를 노드라고한다.

-> 위에처럼 쭉 한반향으로 가면 단일리스트라고한다.

->이중 리스트는 [1]        <->  [2]    <->[3]   <-> [4]    <-> [5]앞뒤로 연결되어있다. 특정 노트 기준으로 전후를 다 알수있다. Node* _next;   Node* _prev;  이렇게하면 안뒤로 연결한다.

->원형 리스트는 [1]        <->  [2]    <->[3]   <-> [4]    <-> [5] <-> 맨마지막 데이터랑 처음에있는 데이터랑 서로 가르키고있으면 원형리스트이다.

​    

중간삽입할 때 끼워넣어서 포인터로 가르키게만 하면 되기 때문에 위에서는 효율적이지 못했는데 여기서는 별 의미가 없다.

### list 단점    

근데 왜 벡터를 우선순위를 두고 사용할까??

->list는 단점이 있다.

​    

리스트

단점:임의 접근(i번째 데이터는 어디 있습니까?) -> li[3]이런식으로 벡터처럼 옹기종기모여있어서 배열처럼 인덱스로 임의 접근이 가능했다. 근데 리스트는 다 떨어져 있어가지고 분리되어 저장되어있고 앞뒤의 주소만 저장되어있어서 넘어갈 수 있는 방법이여서 임의접근이 안된다. 그래서 앞에서부터 한칸 두칸 세칸이런식으로 쭉 가야한다.

​    

메모리를까보면 앞뒤로 이동할 수 있는 주소가 저장되어있고 밑에 실제값이 저장되어있다.

그리고 원형 리스트에서 첫 번째 노드에서 메모리를 보면 뒤로가는 주소가있는데 뒤로가면 맨 마지막에 있는 그걸 연결시켜주는애랑 연결되어있고 거기서 또 타고가면 맨마지막 노드에 접근이가능한다.

끝났다고 더미 노드를 만들어준다. 그 더미가 양 옆으로 연결시켜주는애이다. 

​    

-- 이런식으로 옮기면 끝과 처음으로 옮길 수 있을 것 같은데 잘못된 코드를 잡아주기 위해 연결을 해준 것이지 실질적으로 순간이동을 하는건아니다. 앞에서는 앞으로 가야한다.

근데 맨앞에 있는애가 뒤로가는건 안되는데 맨뒤에 있는애가 뒤로 가는건 가능하다.

++하면 맨뒤에있는가 하면 스크래치난다. 못간다.

그래서 잘못된 이동을 잡아주기 위해서 더미노드를 넣어준다.

### list 중간삽입삭제 원리

근데 중간삽입삭제가 빠른데 왜 찾는거는 느릴까? 먼가 모순적이지 않을까라는 생각이 난다.

그래서 원리를 알아야한다.

-> 임의 접근이 안된다

-> 중간 삽입/삭제 빠르다

-> 50번째에 있는애를 삭제해줘 그러면 앞에서부터 쭉 찾아야하닌간 빠르진않지만 그런데 거꾸로 애당초 삭제를 할 대상을 이테리터 자체를 들고있고 있는 상태이면 빠르다는 상태이다.

-> 이런식으로 위치를 기억하고 있다가 출력할 수 있다.

```c++
int main()
{
    // list 선언
   list<int> li;

    // list의 iterator 선언
    list<int>::iterator itRemember;

    // 0부터 99까지 list에 추가
    for (int i = 0; i < 100; i++) {
        if (i == 50) {
            // i가 50일 때, 50을 list의 끝에 삽입하고 해당 위치를 기억
            itRemember = li.insert(li.end(), i);
        }
        else {
            // 그 외의 경우 list의 끝에 값 추가
            li.push_back(i);
        }
    }

    // 기억한 iterator의 값을 출력
    cout << "Value at itRemember: " << *itRemember << endl;

    return 0;
}
```



-> li.erase(itRemember);

이런식으로 데이터 자체를 뿅 해서 삭제를할 수 있다. 그런데 몇 번인덱스를 삭제해줘라는 의미가 풀과정이 빠르다는 소리는 아니다.

​    

지금까지한거는 스퀸스 컨테이너이다.( Sequence Container)

-데이터가 삽입 순서대로 나열되는 형태

-vector, list, deque