---
layout: single
title: "C++ : 객체지향 "
categories: "C++"
tag: [C++,C++강의]

author_profile: true
sidebar:
    nav: "counts"
---

## 객체지향

함수기반으로 때려박는건 함수기반 객체지향 프로그래밍이다.

문제점: 어마어마하게 큰게임이라고 치면 내가 만들 때 함수가 흐름대로 호출 되는게 아니라 다른사람이 와서 호출 상태를 순서대로 호출을안하고 순서가 달라지면 문제가 생긴다.

프로그래밍: 데이터 + 가공

객체지향의 주인공은 객체이다

객체란? 눈에 보이는 객체 플레이어,몬스터 등 아니면 추상적이나 모든 오브젝트들이다.

객체: 속성(데이터:hp,attack,x,y), 기능(동작:Mov,Attack,Die)

클래스: 설계도 클래스 안에 있는 데이터(변수)는 멤버 변수라고한다. 함수는 멤버함수라고한다.

설계도를 만들어도 메모리에 안올라감 사실상 struct문법이랑 거의 종이차이임 거의 비슷한다.

클래스 선언할때는 void Knight ::Move(int y,int x) 이런식으로 클래스 Knight에 있는 Move함수이다 라는 뜻이다.

설계도를 만들고 Knight k1이런식으로 k1에 바구니를 하나 만들어 변수를 할당할 수 있다. 이걸 객체를 만든다고한다.

Instantiate: 객체를 만든다

```c++
#include <iostream>
#include <cstring>
#pragma warning(disable:4996)
using namespace std;

class Knight
{
public:
	void Move(int y, int x);  //멤버함수 선언
    void Attack();            //멤버함수 선언
	void Die();               //멤버함수 선언

public:
	int hp;         //멤버변수
	int attack;     //멤버변수
	int posY;       //멤버변수
	int posX;       //멤버변수

};

void Knight::Move(int y, int x)       //Knight안에있는 Move멤버함수
{
    
}

int main()
{

	Knight knight;
	return 0;
}
```



그럼 k1.hp =100;

​     k1.attack = 10;

​     k2.hp = 20;

​     k2.attack = 20;

이런식으로 만들 수 있다 그럼 k1과 k2의 객체들은 다른 값을 가지고 있다

그럼 이거랑 구조체랑 비슷한데 차이점은 설계도 안에있는 함수도 실행할 수 있다

K1,K2는 서로 다른 메모리에 잡혀있다.

그럼 저런 클래스를 만들 때 어떻게 저렇게 넘겨줘도 클래스안에서 알 수 있는지 메모리를 보면 실질적으로 잡혀있는 메모리는 데이터선언한 부분만 잡혀있음 함수는 안잡혀있음 메모리로 봤을 때 간접적으로 k1.hp=100할 때 k1의 자기 주소를 보내준다

그래서 결론은 객체지향의 핵심은 객체이다!

### 멤버변수

멤버변수표시할때 mHP, n_Hp, _hp 이건 회사마다 달라서 하고싶은거 하면됨 그래서 자기만의 코딩 규칙을 하나만들어서 통일하는게 좋다_

기계에서보면 this라는게 있는데 클래스안에서 자기를 가르키고싶을 때 this라는걸 만들 수 있다  this->_hp = 0 똑같은 말임 this를 타고가면 객체가 나이다 하고 그 메모리가 있는 부분으로간다

### 생성자,소멸자    

```c++
#include <iostream>
#include <cstring>
#pragma warning(disable:4996)
using namespace std;

class Knight
{
public:
    
    Knight()    //생성자
    {
       	cout<<"Knight() 기본 생성자 호출"<<endl;
    }
    
    ~knight()
    {
        cout<<"Knight() 소멸자 호출"endl;
    }
    
    void Move(int y, int x);  //멤버함수 선언
    void Attack();            //멤버함수 선언
	void Die();               //멤버함수 선언

public:
	int hp;         //멤버변수
	int attack;     //멤버변수
	int posY;       //멤버변수
	int posX;       //멤버변수

};

void Knight::Move(int y, int x)       //Knight안에있는 Move멤버함수
{
    
}

int main()
{

	Knight knight;
	return 0;
}
```

생성자(Constructor) 소멸자(Destructor)

클래스의 소속된 함수들을 멤버 함수라고 한다

이 중에서 굉장히 특별한 함수 2종이 있는데, 바로 [시작]과 [끝]을 알리는 함수들

-시작(탄생) -> 생성자 (여러개 존재 가능)

-끝(소멸) -> 소멸자(오직 1개만)

기본 생성자: 기본 생성자(인자가 없음),반환하는 타입이 없다, 똑같은 이름으로 넣음는다, 많은 기능이 있어서 인자를 받는 생성자도 있다 그런생성자는 기본생성자라고 안하고 그냥 생성자라고한다 인자를 받는애는, 또 복사 생성자가 있는데 생성자는 생성자인데 자기 자신의 참조타입을 인자로 받는다 Knight(const Knight& knight){ } 사용 이유는 똑같은 데이터를 지닌 객체가 생성하기 위해 사용한다.

Knight()

{     }

그냥 이 설계도가 탄생이 되는즉시 호출됨

### 암시적 생성자    

암시적(Implicit)생성자: 생성자를 명시적으로 만들지 않으면, 아무 인자도 받지 않는[기본 생성자]가 컴파일러에 의해 자동으로 만들어진다 ->그러나 우리가 명시적(Explicit)으로 아무 생성자를 하나 만들면 자동으로 만들어지던[기본 생성자]는 더 이상 만들어지지 않는다! 그래서 다른 생성자를 만들면 시스템이 기본생성자를 안만들어주기 때문에 오류가 난다 그래서 기본생성자를 정의해놔야한다.

​    

디폴트로 만들어지는건 기본생성자가 만들어지고 +로 복사 생성자도 하나 만들어줌 그래도 명시적으로 만들어줘야하나? 라는 생각을 하겠지만 일반 데이터는 기본 방식을 사용해도 되지만 참조값이나 포인터가 들어가면 복잡해진다

### 소멸자

소멸자: ~표시를 하나 넣는다, 기본생성자라고 부르지만 소멸자는 안불른다 하나밖에 없어서

~Knight{     }

이 설계도가 사라질 때 호출된다.

### 생성자 종류

Knight k2(k1)  //복사 생성자

Knight k3 = k1;  // 복사 생성자

Knight k4;  //생성자

k4 = k1;    //복사

이건 의미가 다름 기본생성자를 만든다음에 k4에다가 k1을 복사해달라는 의미이다.

k3는 생성을 하자마자 동시에 복사생성자를 생성한다.  

​    

생성자는 유일하게 하나만 생성되고 생성되는 시점에서 어떤 방식으로 만들어졌나해서 어떤생성자가 생성될지가 정해진다

​    

기타 생성자

-> 기본생성자,복사 생성자가 아닌 나머지 애들

-> Knight(int hp, int attack, int posX, int posY){ _hp = hp; _attack =attack; _posX=posX; _posY=posY;} 이렇게 선언

메인에서 Knight k1(100,1,0,0) 이런식으로 호출함 이렇게하면 인자가 4개닌간 기본생성자가 아니라 저걸 호출해야겠군아 하고 알수 있다.

​    

기타 생성자에서 인자를 1개만 받는 기타생성자를 타입 변환 생성자라고 부르기도한다

### 암시적 형변환,명시적 형변환

\- 암시적 형변환 -> 컴파일러가 알아서 바꿔치기함  int num =1;   float f = num; 이렇게 하면 알아서 변환시켜준다

\- 명시적 형변환 -> float f= (float)num -> 내가 이 바구니에 넣으라고 주문한다.

암시적으로 하면 좋지만 많은 버그도 일으킨다.



Knight k5;

k5 = 1;

이렇게하면 타입변환생성자에 들어간다. Knight(int hp) { ~~~~~ }

근데 이렇게하면 버그가 많이 발생해서 명시적인 용도로만 사용한다고 explicit를 붙인다.

explicit Knight(int hp) { ~~~~~ } 

​    

요약해보면 멤버함수중에서 특별한 역할을 가지고 있는 생성과 소멸을 가지고 있는 생성자와 소멸자가 있다 기본 생성자는 반환함수가없고 인자가없다 그리고 생성자는 하나만 있는게 아니라 여러개가 있는 기본생성자 복사 생성자 기타 생성자가 있다 소멸자는 생성자랑 비슷한데 ~하나가 붙어있음 메모리가 날라갈 때 호출되는 함수임 생성자쪽이 복잡한 곳이 많은데 소멸자는 그냥 소멸하면 사라지닌간 별 차이가 없어서 하나의 문법밖에 없고 생성자는 어떤식으로 만들어줄지 옵션이 많다, 그리고 명시적과 암시적이라는게 있어서 명시적은 내가 정해줘서 이 바구니로 담아주라는 의미이고 암시적은 알아서 다른 바구니로 교체해주는걸 말한다 근데 클래스랑 다른 타입끼리에서도 멋대로 변환시켜줄 수 도있어서 생성자에 explicit를 붙여서 명시적인 용도로만 사용한다고 해줄 수 있다. 

​    

여러개의 인자를 받는 생성자타입은 객체의 초기화를 위한것이고 단일 타입만 받는건 객체로 변환하는 목적으로 사용됨 4개 인자를 받는건 초기화를 위해 사용해 자동 변환 기능이 없다.

### 상속성

상속성- class Knight :: public Player  : 나이트는 플레이어의 상속을 받는다

​    

메모리는 어떡게 올라갈까? : 상속을 받을 때 설계도는 Player를 만들기위해서 먼저 만들어서 플레이어를 만들고 확장된 나이트느낌임 플레이어 기반으로 건물을 짖는다. Player에 있는 데이터를 만들고 Knight에 있는 추가정보가 붙어서 나온다.

​    

상속받았는데 부모님의 유산을 거부하고 새로운 이름을 만들 수 있음 근데 다른데 메모리에 옮겨놓고 사용하는것이다.(재정의 가능)

​    

상속받았을 때 엄마 생성자를 호출해야하는지 상속받은사람의 생성자를 호출하는게 맞는지?

시스템에서는 그냥 둘다 호출하자 -> 부모의 생성자 나오고 상속받은사람 생성자 나오고 소멸자는 그반대로 상속받은사람이 먼저나오고 부모의 소멸자가 나온다.

​    

근데 메모리로 보면 정확히 말하면 나이트라는 생성자를 호출할 때 일반 함수랑 좀 다르게 동작해 생성자 안에 있는 코드만 실행하는게아니라 안보이는 먼저 실행하는(선처리영역)부분이 있다 거기서 부모의 생성자를 호출하고 있다 그래서 순서만보면 상속받은사람이 먼저 호출되고 부모의 생성자가 호출된다 자식의 생성자가 호출되기 직전에 호출된다 부모의 생성자가

``` c++
class Knight : public Player{

public:

   Knight()
   //이부분에서 먼저 부모의 생성자를 호출함  

   {    

​      

​     _stamina = 100  

​    cout<<"Knight() 기본 생성자 호출“ << endl;

   }

}
```

소멸자를 보면 선처리 영역은 없지만 다끝나면 자식의 소멸자가 나오고 그다음에 바로 똑같이 후처리 영역처럼 숨겨져있는데 그부분에 부모의 소멸자가 호출됨 숨어져있다.



생성자와 소멸자는 물려주는 개념이 아니다.

​    

디테일적인 부분에서 부모의 생성자를 기본생성자와 인자하나 받는 생성자를 두 개만들고 상속받는애도 똑같이 두 개 만들고 객체를 호출할 때도 부모의 기본생성자를 호출한다. 근데 내가 다른 생성자를 생성하고싶을 때 특정 문법을 이용해 조작할 수 있다.

Knight(int stamina) : Player(100){      } 이렇게하면 선처리에서 나오는 생성자를 지정해줄 수 있다. 

### 은닉성

```c++
#include <iostream>
#include <cstring>
#pragma warning(disable:4996)
using namespace std;

class Knight
{
public:                            //-> 은닉성
    
    Knight()    //생성자
    {
       	cout<<"Knight() 기본 생성자 호출"<<endl;
    }
    
    ~knight()
    {
        cout<<"Knight() 소멸자 호출"endl;
    }
    
    void Move(int y, int x);  //멤버함수 선언
    void Attack();            //멤버함수 선언
	void Die();               //멤버함수 선언

public:                           // -> 은닉성
	int hp;         //멤버변수
	int attack;     //멤버변수
	int posY;       //멤버변수
	int posX;       //멤버변수

};

void Knight::Move(int y, int x)       //Knight안에있는 Move멤버함수
{
    
}

int main()
{

	Knight knight;                      // 객체 생성
	return 0;
}
```



은닉성: 몰라도 되는 것은 깔끔하게 숨기겠다!

쓰는 이유: 정말 위험하고 건드리면 안되는 경우, 다른 경로로 접근하길 원하는 경우

(멤버)접근 지정자 라고 불름

-public: 공개적, 누구한테나 공개. 실컷 사용하세요~~

-protected: 보호받는, 나의 자손들만 허락

-private: 개인, 나만 사용할 거야 << 내부에서만 사용가능

​    

```c++   
class SuperCar：public Car  
```

-상속 접근 지정자 여기서 public은 좀 다르다.

여기서 나오는 상속 접근 지정자는 다음 세대한테 부모님의 유산을 어떻게 물려줄지? 부모님한테 물려받은 유산을 꼭 나의 자손들한테도 똑같이 물려줘야 하진 않는다.

-public:공개적 상속 부모님의 유산 설계 그대로 (public -> public, protected -> protected)

-protected: 거의 안쓴다, 보호받은 상속 내 자손들한테 물려줌 ( public -> protected, protected -> protected)

-private: 거의 안쓴다, 개인적인 상속 나까지만 잘 쓰고 자손들한테는 아예 안 물려줄 거야 (public -> private, protected -> private)

앞에 설정안해주면 private로 설정된다.

​    

캡슐화: 연관된 데이터와 함수를 논리적으로 묶어놓은 것

```c++
int GetHp() {return _hp;}

void SetHp(int hp)

{

   _hp=hp;
   if(_hp<=50)
   {
    SetBerserkerMode();
   }
​  
}
```

hp값 보고싶으면 GetHp 사용

세팅하고싶으면 SetHp 사용 

이렇게 한게 캡슐화임 

### 다형성

```c++
#include <iostream>
#include <cstring>
#pragma warning(disable:4996)
using namespace std;

class Player
{
public:
	virtual void VMove(){cout<<"VMove Player"<<endl;}            // 가상함수 virtual
}


class Knight : public Player        //상속
{
public:
    
    Knight()    //생성자
    {
       	cout<<"Knight() 기본 생성자 호출"<<endl;
    }
    
    ~knight()
    {
        cout<<"Knight() 소멸자 호출"endl;
    }
    
    void Move() {cout <<"Move Player !"<<endl;}                    // 다형성(오버로딩)
    void Move(int a){cout<<"Move Player(int)"<<endl;}              //다형성(오버로딩)
	virtual void VMove(){cout<<"VMove Knight"<<endl;}              //다형성(오버라이딩)
};

void Knight::Move(int y, int x)       //Knight안에있는 Move멤버함수
{
    
}

int main()
{

	Knight knight;
	return 0;
}
```



다형성(Polymorph): 겉은 똑같은데 기능이 다르게 동작한다

-오버로딩   = 함수 중복 정의 = 함수 이름의 재사용

-오버라이딩   = 재정의 = 부모 클래스의 함수를 자식 클래스에서 재정의

-바인딩: 묶는다, 정적 바인딩, 동적 바인딩

정적 바인딩: 컴파일 시점에 결정

동적 바인딩: 실행 시점에 결정(면접 단골 질문이다.)

어떤 함수를 묶어서 매핑할지 정하는데 그게 바인딩이다.

일반함수는 정적 바인딩을 사용한다.

동적 바인딩을 원한다면? -> 가상함수를 이용

함수 앞에 virtual 붙이면 됨

가상 함수는 재정의를 하더라도 가상 함수이다. -> 가상함수를 만들고 밑에서 virtual를 안붙여도 가상함수라는 의미

​    

그런데 실제 객체가 어떤 타입인지 어떻게 알고 알아서 가상함수를 호출해준걸까?

-가상 함수 테이블 (vftable)

-.vftabel[]  -> [] [] [] [] 적혀있다. 하나씩

​    

가상테이블을 채우는 주체는 누구인가? 생성자에서 해줌 선처리생성자에서 가상테이블을 채워넣는다. 

​    

순수 가상 함수: 구현은 없고 ‘인터페이스’만 전달하는 용도로 사용하고 싶을 경우

\- virtual void VAttack() = 0;     -> 0이들어가 있으면 순수 가상 함수

->이걸 하나라도 만드는 순간 ‘추상 클래스’로 변경된다.

-> 추상 클래스로 만들어지면 직접적으로 객체를 만들 수 없게 된다.

-> 자손에서 만들어서 넘겨줘야 사용할 수 있다.





​    

