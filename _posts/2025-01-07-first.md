---
layout: single
title: "C++ : 포인터,타입불일치,스택프레임,전역변수,지역변수,오버로딩,스택 오버플로우,포인터 연산,참조타입,포인터vs참조"
categories: "C++"
tag: [C++,C++강의]

author_profile: true
sidebar:
    nav: "counts"
---

## 포인터

type* 변수이름; : 바구니는 바구니 [주소를 저장하는 바구니이다!]

```c++
#include <iostream>
using namespace std;

int main()
{
    int number = 0;
    int* ptr = &number;
}
```

int* ptr = &number;    ->  number의 주소를 ptr에다가 넣어주세요

-> &ptr 메모리 주소를 까보면 들어있는데 값이라니라 number의 주소를 들고있다

*가 붙는 경우: 포인터라는 바구니는 4바이트(32비트) or 8바이트(64비트) 고정 크기이다

앞에 어떤 타입이 붙어도 고정임 요즘은 8바이트만 쓴다



이제 남의 주소를 갖고 다른거 할 수 있는 방법

```c++
#include <iostream>
using namespace std;

int main()
{
    int number = 0;
    int* ptr = &number;
    *ptr = 100;
    cout << number << endl;
}
```

-[주소를 저장하는 바구니]가 가르키는 주소로 가서 무엇인가를 해라!

-그냥 ptr은 주소를 담는 바구니이다. 하지만 *변수이름=값; 을 하면 그 주소에 들어가서 값을 변경할 수 있다. 

-포탈을 타고 순간이동 한다고 생각하자

-*이 여러번 등장하니 헷갈리는데, 사용 시점에 따라서 구분해서 기억하자

-변수 선언(주소를 저장하는 바구니)

-변수를 사용할 때 (포탈을 타고 순간이동)

-어셈블리어 lea -> 오른쪽에 있는 주소를 왼쪽에 넣어주세요라는 뜻

### 포인터타입이 필요한 이유

포인터에 왜 타입을 왜 붙여주는가??

\- 어떤 주소를 건네받았을 때 그 주소에 가면 머가 있는지가 더 중요하다 

\- 예를 들면 결혼식 청접장에 있는 주소= 예식장 주소

\- 명함에 있는 주소는 해당 명암 준사람의 = 회사주소

\- * = 포인터(주소 담는 바구니)

\- 해당 주소를 갔을 때 그데이터는 무엇무엇으로 판단해줘 이런 느낌이다

\- 그래서 타입은 이 포인터에 갔을 때 어떤식으로 바라볼지를 정해주는 것 이다

\- 이 주소에 가면 무슨 타입의 값이 있을 것이다. 이런식으로 있다



### 타입불일치

-타입을 불일치시키면 다른 주소에다가 값을 저장해버리는 경우가 있음 그래서 포인트를 쓸때는 잘 생각하고 이용해야함

##  visual studio 단축키

F5: 디버깅 시작  한번더 눌르면 브레이크포인트에 걸린다

F10: 함수 단위로 큰 덩어리로 실행 

F11: 한줄 한줄씩 실행함

## 스택프레임

메모리 구조

![메모리 구조]({{site.url}}/images/2025-01-07-first/메모리 구조.png)

스택 -> 메모장이라는 이유는 정해진 메모리크기가 있는데 함수 자기들끼리 난 이정도만 쓸거야 나눠지는거여서 메모장이라고함 정해진 크기가 있음 운영체제가 정해준다.

스택에서

지역변수    

변환 주소값

매개변수

이렇게 세트입니다.

스택에 대해서 이렇게 잘 알아야하나 하는데 c++에서는 메모리를 조작할 수 있기 때문에 문제가 터졌을 때 어떤 방식으로 동작하는지 이해를 해야 잘 알고있어야함

## 전역변수,지역변수

전역변수: 함수밖에 선언하면 전역변수, 어떤 함수건 다 접근해서 사용가능하다.

-초기화 여부,const등 rodata,data,bss에 들어가는데 통틀어서 그냥 데이터메모리라고 한다.

지역변수: 함수안에 선언하면 지역변수이다.

-스택 영역에 있다

-스택에 있어서 다루기 까다롭다

-스택에 함수 자기들끼리 땅따먹기하는 듯이 영역을 먹어서 스택에 한 메모리부분을 차지하기 때문에 내가쓴 변수를 다른데서 사용할 수가 없다.

### 전역변수vs지역변수

전역변수와 지역변수를 만들때는 왠만하면 지역변수로 만드는게 좋음 전역변수로 만들면 나중에 코드줄이 엄청길어질 때 관리하기 너무 어려워짐 지역변수는 자기 물건을 자기가 책임지는거닌간 나중에 고치기 쉽다.

### stack

stack에서 매개변수 리턴주소 지역변수 이렇게 하나의 스택프레임이 쌓이는데 여기서 매개변수와 리턴주소는 이전 함수에서 대신 넣어준 다음에 토스를 해주는개념임 지역변수부터 자기가 제어하는 부분이다.

처음에 함수가 만들어지면 매개변수 RET 지역변수가 만들어지는데 다음 함수를 호출할 때 처음에 전에있던 함수가 매개변수값을 PUSH PUSH해서 세팅을해준다음에 내 리턴주소를 RET에다가 저장해주고 다음함수 시작 주소로 그 코드로 넘어가서 실행한다.

### 함수 선언

C++같은 경우 언어가 무숙함 그래서 컴파일을 할 때 순차적으로 위에서부터 아래로 하나씩 하나씩 뭔가 분석을 한다고보면 됨 그래서 함수를 호출할 때 다음 스택에 들어오는 함수를 호출할 때 위치를 몰라 함수를 호출할 수 없게되는데 그거를 해결하기 위해서 함수 선언을한다.

함수 선언: 위에다가 그냥 void Func1(인자값); 이런식으로 간단하게 한다.

함수를 구현하는 부분 함수를 선언하는 부분 두 개를 만들어서 사용한다.

### 호출스택

함수가 너무 많아져서 함수안에 계속 추적하면서 가야하는데 이거를 레지스터를 뜯어보고 메모리 보고 해서 가는건 말이 안된다. 그래서 호출 스택이라는게 있는데 디버그에서 보면 호출 스택이라는 창이 있는데 내가 어떤 경로를 통해서 왔는지 적혀있다 반환 주소값을 하나하나 알려준다.

호출스택을 열심히 보는 능력을 키워서 빠르게 코드 전체적인 맥락을 파악할 수 있어야함

## 오버로딩

```c++
#include <iostream>
using namespace std;

void Add(int,int);
void Add(int, int, int);
int main()
{

	int b = 1;
	int c = 2;
	int d = 3;
	Add(b, c, d);
}
void Add(int b, int c)
{
	int sum = b + c;
	cout << sum << endl;
	return;
}
void Add(int b, int c, int d)
{
	int sum = b + c + d;
	cout << sum << endl;
	return;
}

```

오버로딩(중복 정의) : 함수 이름의 재사용

조건 -> 매개변수 개수가 다르거나, 매개변수 타입이 다르거나(순서가 다른걸 포함)

기본 인자값: 밑에 예시처럼 값을 0으로 세팅해놓으면 인자값이 없으면 알아서 0으로 초기화시켜준다 대신 기본 인자값을 세팅할때는 뒤쪽에 놔야함 중간에 놓거나 다른데 넣으면 인자값을 어디다가 넣어야하나 컴퓨터가 고민되게해서 그런다.

void SetPlayer Info(int hp, int mp, int attack, int guidld=0 <-기본 인자값){     }

SetPlayer Info(100,40,10)

## 스택 오버플로우

스택 오버플로우

\- 스택메모리에 계속 차다보면 메모리 용량이 터지는 현상

팩토리얼: 5!: 5*4*3*2*1, 4!: 4*3*2*1 , n!= n*(n-1) 실험하기 위해 이걸 이용해  엄청 많은수를 계산하면 오버플로우가 일어난다.

## 구조체

구조체: 타입을 묶어준다

어셈블리어로 까보면 딱히 묶여있는 느낌이 아니라 하나하나 그냥 변수선언된 느낌이다.

구조체에서 int타입 4개있으면 16바이트가 할당될거라고 생각하는데 맞다.

하지만 여기서 타입이 각자 다르면 shor int char int 보면 11바이트일 거라고 생각하지만 실제로는 까보면 패딩이라는 빈 공간이 추가된다. 그리고 빈 공간을 넣어주는 이유는 컴퓨터가 자기가 계산하기 쉽게끔 자기가 빠르게 처리할 수 있게끔 강제적으로 조절해가지고 정렬을 맞춰준다. 그래서 크기가 안맞을 수 도있다.

## 포인터 연산

1.주소 연산자(&)   : 해당 변수의 주소를 알려주세요

2.산술 연산자 (+,-)   :  + - 연산

int number = 1;

int* pointer = &number;

number += 1;     //여기서 산술적으로 1이 증가됨

pointer += 1;     //주소가 1이 아니라 4가 증가가됨 -> 왜 4가 증가되었는가? : 포인터에서 +나 -등 산술 연산으로 1을 더하거나 빼면, 정말 ‘그 숫자’를 더하고 빼라는 의미가 아니고 한번에 TYPE의 크기만큼을 이동해라! 그래서 여기서 int형 4만큼 증가가된다.(다음/이전 바구니로 이동하고 싶다 ,[바구니 단위]의 이동으로 즉 1을 더하면 바구니 1개 이동시켜라 3을 더하면 바구니 3개 이동시켜라라는 뜻이다.

-쓰는 이유: 배열을 사용할 때 이용한다.

3.간접 연산자(*) : 포탈을 타고 해당 주소로 슝~이동하고 저장해라라는 의미

-*pointer = 3;(간접 연산자)   , number =3; 이거랑 똑같은 의미이다.

4.간접 멤버 연산자(->)

-오프셋 struct안에 주소를 사용해서 사용할 때 메모리 주소가 0 ->4 ->8 4씩 늘어나면서 주소에 저장해줌 (*playerPtr).hp = 200; 이렇게하기 귀찮으닌간 간접 멤버 연산자가 있다.

playerPtr->hp = 200; 이런식으로

-* 포탈 타고 해당 주소로 간다음 

-.은 구조체의 특정 멤버를 다룰 때 사용하는 것 이다.(어셈블리 언어로 까보면 사실상 그냥 덧셈)

\- ->는 *이거와 . 이걸 한방에 처리해준다.

### 분석하는법

int* -> 오른쪽부터 보기 -> * 포인터 타입이네(8바이트) 주소를 담는 바구니 -> int: 해당 주소를 따라가면 int(4바이트 정수형 바구니)가 있다고 가정

### 성능

반환값으로 넘겨줄때는 복사가 많이 일어나 성능적인 문제가 있어서 주소값으로 넘겨줄 때가 성능적으로 더 좋다

## 참조타입

-값 전달 방식 ( void CreateMonster(statInfo info)   )

경우에 따라서는 값만 읽어오고싶은 상태가 있으면 주소에서 값을 변경하는게 아니라 그냥 값만 복사해서 넘겨줘도됨  void CreateMonster(statInfo info)처럼 / 그냥 값만 읽어오는 방식은 사용하면 된다.

-주소 전달 방식 (  void CreateMonster(statInfo* info) )

StatInfo 구조체가 1000바이트짜리 대형 구조체라면?

-(값 전달) StatInfo로 넘기면 1000바이트가 복사되고

-(주소 전달) StatInfo는 8바이트

-그래서 커질수록 주소전달을 해줘야 성능적으로 훨씬 좋다.



-참조 전달 (    void PrintInfoByRef(StatInfo& info)     )

-c++만 있는 거임

-실제 어세블리 관점에서 작동 방식을 보면 int*와 똑같다  ->100프로 똑같다 

-c++관점에서는 number라는 바구니에 또 다른 이름을 부여한 것

-number라는 바구니에 reference라는 다른 이름을 지어줄게~~

\- 앞으로 reference 바구니에다가 뭘 꺼내거나 넣으면

\- 실제 number바구니 (진퉁에다가) 그 값을 꺼내거나 넣으면 됨!

\- 포인터나 레퍼런스가 똑같은데 왜 귀찮게 레퍼런스로 이름을 만들어서 짓는 이유는?

->참조전달 장점, 값 전달 방식의 .만 찍어서 접근할 수 있는 방식과 ->이걸 사용안해도 됨 그리고 성능적인 주소 전달 방식의 장점이 있다.

-int&(참조타입 reference) = number

## 포인터 vs 참조

-성능: 똑같다.

-편의성: 참조 승 (하지만 편의성이 좋다는게 꼭 장점만은 아니다. 포인터는 주소를 넘기니 확실하게 원본을 넘긴다는 힌트를 줄 수 있는데, 참조는 자연스럽게 모르고 지나칠 수도 있다.)

-참조에서 그래서 const를 사용해서 이런 마음대로 고치는 부분을 개선가능하다.

-참고로 포인터도 const를 사용 가능 (*기준으로 앞에 붙이느냐, 뒤에 붙이느냐에 따라 의미가 달라진다) -> 별 뒤에 붙이면 주소값을 못고치게 막고 별 앞에 붙이면 주소값에 가서 있는 데이터 값을 바꾸지못한다.

초기화 여부

-참조타입

1. 참조 타입은 바구니의 2번째 이름
2. 참조하는 대상이 없으면 안된다
3. 없다라는 표기가 없다

-포인터타입

1. 아무런값도 안가져도 지정할 수 있다

2. 어떤 ~주소라는 의미라 대상이 실존하지 않을 수도 있다

3. 포인터에서 없다의 의미로 넣어줄라면 nullptr;를 초기화시켜주면 된다

4. 없다라는걸 표기하고싶으면 포인터가 좋다

   

그래서 결론은?

\- 정해진 답은 없다

\- ex)구글에서 만든 오픈소스를 보면 거의 무조건 포인터 사용한다.

\- ex) 언리얼 엔진에선 reference도 애용한다.

\- 성능차이는 없다보닌간 아무거나 써도 상관없다

\- 없는 경우를 고려한다면 포인터(null 체크 필수)

\- 바뀌지 않고 읽는 용도만 사용하면 const ref&

\- 그 외 일반적으로 ref(명시적으로 호출할 때 OUT을 붙인다) -> OUT StatInfo& info 그리고 #define OUT를 선언해 그냥 아무의미가 없지만 힌트를 준다 값이 바뀔 수 있다 라는 의미 가독성 높이기 위해

\- 단 다른사람이 포인터를 만들어놓은걸 이어서 만드는 상황이 있으면 포인터를 사용하면 된다.(섞어서 사용은 잘 안한다.)







​    













