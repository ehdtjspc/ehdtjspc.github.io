---
layout: single
title: "C++ : 배열,포인터vs배열,이중포인터,다차원배열"
categories: "C++"
tag: [C++,C++강의]

author_profile: true
sidebar:
    nav: "counts"
---

## 배열

```c++
#include <iostream>
using namespace std;

int main()
{
	int arr[10] = {};
	arr[1] = 3;
	arr[3] = 2;
	arr[5] = 7;

	cout << arr[1] << endl;
	cout << arr[3] << endl;
	cout << arr[3] << endl;        // 순서대로 위에부터 3 2 7이라는 값이 나온다.
}
```

배열의 필요성: 나중에 몬스터가 엄청 많아서 하나하나 해줄 수없어서 몬스터를 하나로 묶어서 편하게 사용하기 위한 방법

TYPE 이름[개수];

배열의 이름은 다른 바구니의 이름이랑 좀 다르게 동작한다.

배열의 이름은 ->　곧 배열의 시작 주소이다, 정확히는 시작 위치를 가리키는 TYPE* 포인터

auto: 조커카드 상대의 타입을 추측해서 나도 타입을 그걸로 설정한다.

그래서 배열에서 +1을 하면 포인터처럼 주소값을 가르킨다.



StatInof monsters;

StatInof& monster = *(monsters +2)          -> 참조

StatInfo* monster = monsters+2                -> 포인터



*(monsters+i)너무 불편하고 가독성이 떨어짐 그래서 더 편한 방법은?

-인덱스 활용

-배열은 0번부터 인덱스가 시작해서 N번째에 인덱스에 해당하는 데이터에 접근하려면 배열이름[N]붙여주면된다.  -> monsters[i]



배열 초기화 문법

\- int numbers[5] = { , , , , ,};    -> 설정한애들은 설정한 값들로 나머지 값들은 0으로 초기화

\- int numbers[] = { 123,23,4213,21321,413,...}; 데이터 개수만큼의 크기에 해당하는 배열로 만들어준다.

정리: 한땀한땀 하나씩 관리하는게 아니라 묶어서 연속한 똑같은 타입의 데이터를 한번에 관리를함 아파트같은 느낌이다.

간단하게 설명하면

1) 선언한다   -> int arr[10] = { };
2) 인덱스로 접근해서 사용 -> arr[1] =1;
3) 꺼내서 사용한다 cout << arr[1] <<endl;

### 포인터 vs 배열

포인터: 주소를 담는 바구니

배열: 배열은[닭장] 즉, 그 자체로 같은 데이터끼리 붙어있는 ‘바구니 모음’

-다만 [배열 이름]은 ‘바구니 모음’의 [시작주소]이다.

-함수에 인자값을 넘겨줄 때 배열을 넘길땐 다 보내는게 아니라 시작주소만 보냄 그래서 배열은 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환한다. char[] -> char*

그래서 배열의 내용 전체를 넘긴게 아니라,시작 주소 (포인터)를 넘김

## 이중포인터(**)

```c++
#include <iostream>
using namespace std;

int main()
{
	const char* msg = "Hello";
	const char** pp = &msg;
	cout << *pp << endl;        //Hello의 주소를 들고 있고 *을 한번더 붙여 역참조하여 그 값이 나온다.
}
```

오른쪽부터 보면 첫 번째보는 *을보면 포인터이다 주소를 담는 바구니이다.
const char* msg = "Hello";
const char** pp= &msg;

->(pp)[주소1(&msg)]    처음에는 그냥 pp의 const char의 2차포인터 이고 

->주소1(msg)[주소2(Hello주소)]    msg는 const char포인터타입이고

->주소2[](.rdata Hello주소 HELLO\N )  const char 타입으로 되어있다.

다중포인터는 양파까기라고 생각하면된다.

const char** pp2;

*을 하나씩 까면서 타고 간다고 생각하면된다

참조도 가능

## 다차원 배열

```c++
#include <iostream>
using namespace std;


int main()
{
	int apartment2D[2][5] = { {4,2,3,4,1},{1,1,5,2,2} };
	
	for (int floor = 0; floor < 2; floor++)
	{
		for (int room = 0; room < 5; room++)
		{
			int num = apartment2D[floor][room];
			cout << num << " ";
		}
		cout << endl;  //여기서 순차적으로 쭉 다 돌면서 보닌간 4 2 3 4 1 이렇게 나온다.
					   //		                         1 1 5 2 2       
	}
	return 0;
}
```

2차원 배열

```c++
int apartment2D[2][5] = { {4,2,3,4,1},{1,1,5,2,2} };
```

->[] [] 여기에 넣고싶은 크기 넣고 {} {} 여기다가 넣고싶은 값을 넣으면된다.->2차원배열에서 메모리가 옹기종기 다 모아서 같은 타입끼리 닭장처럼 만들어져있음 이어서 닭장처럼 만들어져있다.

그래서 결국에는 2차원배열로 만들어도 메로리가 쭉 옆에 붙어서 닭장처럼 만들어져있어서 1차원배열로도 2차원처럼 만들어도 성능이 완전히 똑같다

## 기타

알고리즘 문제 풀때는 쿨하게 전역변수 만들어서 메모리 관리안해도 된다.

보통 파일 분할 관리할 때 cpp함수 하나 헤더파일 하나 이렇게 만들어서 관리해야 좋음 왜냐하면 헤더파일에 함수를 구현하고 cpp파일에 함수를 구현하면 나중에 사용할 때 어떤 함수를 사용해야할지 몰라서 오류난다.

\#pragma once : 중복해서 나오는애들이나오면 오류나오면 안되닌간 필요한 애 한명만 나오고 나머지 애들이 씹히게만들게 해준다.   ->공식문법은 아니여서 옛날 방식을 쓰는사람도 있는데 그게 #ifndef (_TEST_H__)  #define (_TEST_H__)   #endif 3개 세트로 사용  ( )는 이름      

#pragma once로 하면 최적성은 더 좋지만 간혹 컴파일러할 때 버그가 날 수 있다.

컴파일 -> 링킹 과정을 통해 컴파일로 처음 파일을 돌리고 링킹에서 모든 개별 파일을 돌면서 이 함수가 가지고 있나 확인하고 출력해준다.

​    